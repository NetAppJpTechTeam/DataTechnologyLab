==============================================================
Level 3: CI／CDパイプラインを構築
==============================================================


目的・ゴール: コンテナ化したアプリケーションのCICDを実現する
=============================================================

アプリケーションをコンテナ化したら、常にリリース可能な状態、自動でデプロイメントを出来る仕組みをつくるのが迅速な開発をするために必要になります。

そのためのCI/CDパイプラインを作成するのがこのレベルの目標です。

.. image:: resources/cicd_pipeline.png


本ラボでは Level1, Level2 で行ったオペレーションをベースにCI/CDパイプラインを構築します。

Gitにソースがコミットされたら自動でテスト・ビルドを実現するためのツール(Jenkins)をkubernetes上へデプロイ、及び外部公開をします。
そして、Jenkinsがデプロイできたら実際にアプリケーションの変更を行い自動でデプロイするところまでを目指します。

流れ
=============================================================

#. Jenkins をインストールする
#. Jenkins 内部でジョブを定義する。
#. あるアクションをトリガーにビルド、テストを自動実行する。
#. 自動でk8sクラスタにデプロイメントできるようにする。

CI/CDパイプラインの定義
=============================================================

このラボでのCI/CDパイプラインの定義は以下を想定しています。

* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* テスト実行
* k8sへアプリケーションデプロイ

GitはGitLabを共有で準備していますが、使いなれているサービス(GitHub等)があればそちらを使って頂いても構いません。
まずは、Jenkinsをkubernetes上にデプロイしてみましょう。

Git自体も併せてデプロイしてみたいということであればGitLabをデプロイすることをおすすめします。
GitLabを使えばコンテナのCI/CDパイプライン、構成管理、イメージレジストリを兼ねて使用することができます。


Jenkinsのデプロイ方法について
=============================================================

CI/CDパイプラインを実現するためのツールとしてJenkinsが非常に有名であることは周知の事実です。
このラボではJenkinsを使用しCI/CDを実現します。

まずは、各自Jenkinsをデプロイします。

方法としては3つ存在します。

#. Helm Chartでデプロイする方法 (手軽にインストールしたい人向け)
#. Level1,2と同じようにyamlファイルを作成し、デプロイする方法(仕組みをより深く知りたい人向け)
#. Kubernetes用にCI/CDを提供するJenkins Xをデプロイする方法(新しい物を使いたい人向け)

今回は最初のHelmでデプロイするバージョンを記載しました。
好みのもの、挑戦したい内容に沿って選択してください。

オリジナルでyamlファイルを作成する場合は以下のサイトが参考になります。

    https://cloud.google.com/solutions/jenkins-on-kubernetes-engine

Helmを使ってJenkinsをデプロイ
=============================================================

.. include:: jenkins-install-with-helm.rst

Helm以外でJenkinsをデプロイした場合
=============================================================

本セクションに記載してあることはオプションです。

必要に応じて実施してください。

外部にアプリケーションを公開する方法として ``Ingress`` があります。
Helmを使ってJenkinsをインストー時にvalues.yamlで設定を行うことでIngressが作成されます。
それ以外の手法を取った場合は、kubernetesクラスタ外のネットワークからアクセスできるようにIngressを作成しアクセスする方法があります。

Ingressの導入についてはLevel4 運用編の :doc:`../Level4/ingress/ingress` にまとめました。

Jenkinsの設定をする
=============================================================

.. include:: jenkins-configuration.rst

Jenkins Pipelineの作成
=============================================================

* テスト実行
* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* アプリケーションデプロイ

上記のようなパイプラインを作成にはJenkins pipeline機能が活用できます。

- https://jenkins.io/doc/book/pipeline/
- https://github.com/jenkinsci/kubernetes-plugin/blob/master/README.md

ここではテンプレートを準備しました、上記の様なパイプラインを実装してみましょう。
Jenkins ではパイプラインを構築するために２つの記述方法があります。

- Declarative pipeline syntax https://jenkins.io/doc/book/pipeline/#declarative-pipeline-fundamentals
- Scripted pipeline syntax https://jenkins.io/doc/book/pipeline/#scripted-pipeline-fundamentals

それぞれの違いついてはこちら。

- https://jenkins.io/doc/book/pipeline/#declarative-versus-scripted-pipeline-syntax

.. literalinclude:: resources/jenkins/jenkinsfile
        :language: groovy
        :caption: Jenkins pipelineのフォーマット


.. literalinclude:: resources/jenkins/KubernetesPod.yaml
        :language: yaml
        :caption: Jenkins pipelineをkubernetesで動作させるコンテナのテンプレート


Jenkins pipeline の作成が完了したら任意のGitリポジトリにpushします。
以降のJenkins Pipelineの実行にJenkinsfileを使用します。


アプリケーションの変更を検知してデプロイメント可能にする
=============================================================

CI/CDのパイプラインを作成したら実際にアプリケーションの変更をトリガー(ソースコードの変更、Gitリポジトリへのpush等)としてk8sへアプリケーションをデプロイします。

ポリシーとして大きく2つに別れます、参考までに以下に記載いたします。

* デプロイ可能な状態までにし、最後のデプロイメントは人が実施する（クリックするだけ）
* デプロイメントまでを完全自動化する

実際にkubernetes環境へのデプロイができたかの確認とアプリケーションが稼働しているかを確認します。

今回はサンプルとしてJenkinsのBlueOcean pluginを使用してPipelineを作成します。

.. image:: resources/jenkins_blueocean.png

BlueOcean plugin を使用するとウィザード形式でPipelineを作成することができます。

各入力値については以下のURLにてどのような形式で入力されるかの記載があります。

- https://jenkins.io/doc/book/blueocean/creating-pipelines/

コンテナをCI/CDする方法 Helmを使ってみる
=============================================================

コンテナのCI/CDではいくつか方法があります。
ここではコンテナをCI/CDするために必要な検討事項を記載するとともに

個別のアプリケーションデプロイメントからHelm Chartを使ったデプロイメントに変更します。

作成したコンテナをHelm Chartを使ってデプロイするようにします。

Helm Chartの開発ガイドは以下のURLを確認ください。

- https://docs.helm.sh/chart_template_guide/#the-chart-template-developer-s-guide

他にも以下のようなCI/CDを行いやすくする構成管理・パッケージマネジメントのツールが存在しています。

- Kustomize
- Draft
- GitKube
- Skaffold

デプロイメントのさらなる進化
=============================================================

CI/CDプロセスを成熟させていくと常にリリース可能な状態となっていきます。
そのような状態になると本番環境へのデプロイを迅速にし、ダウンタイムを最小化するための方法が必要になってきます。
元々存在するプラクティスや考え方となりますがコンテナ技術、kubernetesのスケジューラー機能を使うことで今までの環境とくらべて実現がしやすくなっています。

Blue/Greenデプロイメント, Canary リリースというキーワードで紹介したいと思います。

.. tips::

    CDには２つの意味を含んでいるケースがあります。文脈に応じて見分けるか、どちらの意味か確認しましょう。

    * Continuous Deployment: 常にデプロイ可能なものを生成するまでを自動化する、最後のデプロイメントは手動で実施。
    * Continuous Delivery: 本番環境へのデプロイメントまでを自動化する。

Blue/Greenデプロイメント
-------------------------------------------------------------

従来のやり方では1つの環境にデプロイし何かあれば戻すという方法をほとんどのケースで採用していたかと思いますが、さらなる進化として常に戻せる環境を準備し迅速にロールバック
新バージョン、旧バージョンをデプロイしたままルータで切り替えるようになります。

様々な企業で行き着いている運用でもあるかと思いますが、2010年にBlueGreenデプロイメントという名称で説明しています。

- https://martinfowler.com/bliki/BlueGreenDeployment.html

実現方法、切り替えのタイミングなどあり、BlueGreenの実装の決定的なものはなく、1つのプラクティスとして存在しています。

2つの環境を準備し、どこかのタイミングで切り替えを行うためDBのマイグレーションの方法などを検討する必要はでてきます。

Canary
-------------------------------------------------------------

Canary リリースは BlueGreen デプロイメントと類似したデプロイメントになります。
Blue／Green デプロイメントはすぐに古いバージョンにもどせるように仕組みを整えたものですが、Canaryリリースは新しいバージョン、旧バージョンにアクセスする比率を決めてデプロイするプラクティスです。

こちらは2つの環境ではなく、1環境に複数バージョンのアプリケーションが存在することになります。そのためDBのデータをどのように取り扱うかは検討が必要となります。


まとめ
=============================================================

このラボではコンテナ化したアプリケーションのCI/CDパイプラインの構築に挑戦しました。
CI/CDパイプラインを作成するためのJenkins/GitLabをインストールするために必要なHelmが使えるようになりました。

本ラボでは簡易的なパイプラインを実際に構築しました。パイプライン内の処理については個々で実装したものから発展させ様々な処理を追加することができます。

ここまでで Level3 は終了です。
