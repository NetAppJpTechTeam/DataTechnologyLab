==============================================================
Level 3: CI／CDパイプラインを構築
==============================================================


目的・ゴール: コンテナ化したアプリケーションのCICDを実現する
=============================================================

アプリケーションをコンテナ化したら、常にリリース可能な状態、自動でデプロイメントを出来る仕組みをつくるのが迅速な開発をするために必要になります。

そのためのCI/CDパイプラインを作成するのがこのレベルの目標です。

.. image:: resources/cicd_pipeline.png


本ラボでは Level1, Level2 で行ったオペレーションをベースにCI/CDパイプラインを構築します。

Gitにソースがコミットされたら自動でテスト・ビルドを実現するためのツール(Jenkins)をkubernetes上へデプロイ、及び外部公開をします。
そして、Jenkinsがデプロイできたら実際にアプリケーションの変更を行い自動でデプロイするところまでを目指します。

流れ
=============================================================

#. Jenkins をインストールする
#. Jenkins 内部でジョブを定義する。
#. あるアクションをトリガーにビルド、テストを自動実行する。
#. 自動でk8sクラスタにデプロイメントできるようにする。

CI/CDパイプラインの定義
=============================================================

このラボでのCI/CDパイプラインの定義は以下を想定しています。

* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* テスト実行
* k8sへアプリケーションデプロイ

Gitは共有で準備しています。

ここではJenkinsをkubernetes上にデプロイしてみましょう。

Git自体も併せてデプロイしてみたいということであればGitLabをデプロイすることをおすすめします。
GitLabを使えばコンテナのCI/CDパイプライン、構成管理、イメージレジストリを兼ねて使用することができます。


Jenkinsのデプロイ方法について
=============================================================

CI/CDパイプラインを実現するためのツールとしてJenkinsが非常に有名であることは周知の事実です。
このラボではJenkinsを使用しCI/CDを実現します。

まずは、各自Jenkinsをデプロイします。

方法としては3つ存在します。

#. Helm Chartでデプロイする方法 (手軽にインストールしたい人向け)
#. Level1,2と同じようにyamlファイルを作成し、デプロイする方法(仕組みをより深く知りたい人向け)
#. Kubernetes用にCI/CDを提供するJenkins Xをデプロイする方法(新しい物を使いたい人向け)

今回は最初のHelmでデプロイするバージョンを記載しました。
好みのもの、挑戦したい内容に沿って選択してください。

オリジナルでyamlファイルを作成する場合は以下のサイトが参考になります。

    https://cloud.google.com/solutions/jenkins-on-kubernetes-engine

Helmを使ってJenkinsをデプロイ
=============================================================

.. include:: jenkins-install-with-helm.rst

Helm以外でJenkinsをデプロイした場合
=============================================================

本セクションに記載してあることはオプションです。

必要に応じて実施してください。

外部にアプリケーションを公開する方法として ``Ingress`` があります。
Helmを使ってJenkinsをインストールした場合は自動でIngressが作成されます。
それ以外の手法を取った場合は、kubernetesクラスタ外のネットワークからアクセスできるようにIngressを作成してみましょう。


.. raw:: html

    <span style="color: red;font-size: 15px">
    注意 <br/>
    Helm chart で Ingress を使用するよう yamlファイルを変更してインストールした場合は自動でIngressが導入されています。<br/>
    そのため、以下の手順はHelmで実施した人は不要です。
    </span>

Ingressの導入についてはこちらに :doc:`ingress` まとめました。

ServiceをDNSへ登録する
==============================================================

HelmでデプロイしたJenkinsにはIngress経由でアクセスします。
そのためホスト名を使用してアクセスします。

.. note::

        なぜそのような仕組みになっているかを知りたい方はJenkinsのHelmチャートをご確認ください。
        https://github.com/kubernetes/charts/tree/master/stable/jenkins

.. code-block:: bash:
        #!/bin/bash

        ETCD="http://192.168.1.1:2379,http://192.168.1.2:2379,http://192.168.1.3:2379"

        ETCDCTL_API=3 /usr/local/bin/etcdctl --endpoints $ETCD "$@"

以下のようにしてDNSに登録可能です(jenkins.user1x.ndxlab.net で 192.168.1x.10 を登録します)

        etcdctl put /dns/net/ndxlab/user1X/jenkins '{"host":"192.168.1x.10"}'


名前解決ができているか確認します。

.. code-block:: console:

        $ nslookup jenkins.user1X.ndxlab.net

Jenkinsの設定をする
=============================================================

Gitリポジトリに変更があったら自動でテストを実行するpipelineを定義します。
このテストは任意で作成してください。

ここでやりたいことは該当リポジトリにコミットがあり、リリースタグが付与された場合に自動でビルド・デプロイをする流れを作成することです。
そのためにはまずJenkinsでGitリポジトリに操作があった場合の動作の定義とKubernetesとの接続の設定をします。

定義出来る動作としては以下の単位が考えられます。
細かく設定することも可能です。運用に合わせた単位で設定します。

* pull request 単位
* release tag 単位
* 定期実行

前述した以下の項目を盛り込みCI/CDパイプラインを作成しましょう。
以下のようなタスクを組み込んだパイプラインを作成します。シンプルなパイプラインからはじめ、必要に応じてステージを追加していきましょう。

Jenkins AgentをKubernetes上で実行できるようにする
-------------------------------------------------------------

Jenkinsからkubernetes上でJenkins agentを実行する場合にはJenkins kubernetes-plugin の導入が必要です。
通常はソースコードの取得から実施することになります。gitを使う場合であればgitのjenkins-pluginが必要です。

本ガイドで準備した values.yaml を使用している場合にはすでにどちらも導入されている状態となります。

ここでは Jenkins から kubernetesへ接続できるようにする設定を提示いたします。

Jeninsログイン後、クレデンシャルを事前に作成します。

jenkins 導入済みのネームスペースにサービスアカウントを作成します。

.. code-block:: console

        kubectl create clusterrolebinding jenkins --clusterrole cluster-admin --serviceaccount=jenkins:default

.. todo :: 手順記載

Configurationから「Kubernetes設定」を選択します。

.. image:: resources/jenkins-configuration.jpg

ここでは必要となるパラメータを設定していきます。

- /etc/kubernetes/pki/apiserver.crtの内容をkubernetes certificate keyへ。


Jenkins Pipelineの作成
-------------------------------------------------------------

* テスト実行
* アプリケーションビルド
* コンテナイメージのビルド
* レジストリへコンテナイメージのpush
* アプリケーションデプロイ

上記のようなパイプラインを作成にはJenkins pipeline機能が活用できます。

- https://jenkins.io/doc/book/pipeline/
- https://github.com/jenkinsci/kubernetes-plugin/blob/master/README.md

ここではテンプレートを準備しました、上記の様なパイプラインを実装してみましょう。

.. literalinclude:: resources/jenkins/jenkinsfile
        :language: groovy
        :caption: Jenkins pipelineのフォーマット



アプリケーションの変更を検知してデプロイメント可能にする
=============================================================

CI/CDのパイプラインを作成したら実際にアプリケーションの変更をトリガーに(ソースコードの変更、Gitリポジトリへのpush等)k8sへアプリケーションをデプロイします。

ポリシーとして大きく2つに別れます、参考までに以下に記載いたします。

* デプロイ可能な状態までにし、最後のデプロイメントは人が実施する（クリックするだけ）
* デプロイメントまでを完全自動化する

実際にkubernetes環境へのデプロイができたかの確認とアプリケーションが稼働しているかを確認します。

コンテナをCI/CDする方法 Helmを使ってみる
=============================================================

コンテナのCI/CDではいくつか方法があります。
ここではコンテナをCI/CDするために必要な検討事項を記載するとともに

個別のアプリケーションデプロイメントからHelm Chartを使ったデプロイメントに変更します。

作成したコンテナをHelm Chartを使ってデプロイするようにします。

Helm Chartの開発ガイドは以下のURLを確認ください。

- https://docs.helm.sh/chart_template_guide/#the-chart-template-developer-s-guide

他にも以下のような構成管理・パッケージマネジメントのツールが存在しています。

.. todo:: 混ざっているので整理。

- Kustomize
- Draft
- GitKube
- Skaffold

デプロイメントのさらなる進化
=============================================================

CI/CDプロセスを成熟させていくと常にリリース可能な状態となっていきます。
そのような状態になると本番環境へのデプロイを迅速にし、ダウンタイムを最小化するための方法が必要になってきます。
元々存在するプラクティスや考え方となりますがコンテナ技術、kubernetesのスケジューラー機能を使うことで今までの環境とくらべて実現がしやすくなっています。

Blue/Greenデプロイメント, Canary リリースというキーワードで紹介したいと思います。

.. tips::

    CDには２つの意味を含んでいるケースがあります。文脈に応じて見分けるか、どちらの意味か確認しましょう。

    * Continuous Deployment: 常にデプロイ可能なものを生成するまでを自動化する、最後のデプロイメントは手動で実施。
    * Continuous Delivery: 本番環境へのデプロイメントまでを自動化する。

Blue/Greenデプロイメント
-------------------------------------------------------------

従来のやり方では1つの環境にデプロイし何かあれば戻すという方法をほとんどのケースで採用していたかと思いますが、さらなる進化として常に戻せる環境を準備し迅速にロールバック
新バージョン、旧バージョンをデプロイしたままルータで切り替えるようになります。

様々な企業で行き着いている運用でもあるかと思いますが、2010年にBlueGreenデプロイメントという名称で説明しています。

- https://martinfowler.com/bliki/BlueGreenDeployment.html

実現方法、切り替えのタイミングなどあり、BlueGreenの実装の決定的なものはなく、1つのプラクティスとして存在しています。

2つの環境を準備し、どこかのタイミングで切り替えを行うためDBのマイグレーションの方法などを検討する必要はでてきます。

Canary
-------------------------------------------------------------

Canary リリースは BlueGreen デプロイメントと類似したデプロイメントになります。
Blue／Green デプロイメントはすぐに古いバージョンにもどせるように仕組みを整えたものですが、Canaryリリースは新しいバージョン、旧バージョンにアクセスする比率を決めてデプロイするプラクティスです。

こちらは2つの環境ではなく、1環境に複数バージョンのアプリケーションが存在することになります。そのためDBのデータをどのように取り扱うかは検討が必要となります。


まとめ
=============================================================

このラボではコンテナ化したアプリケーションのCI/CDパイプラインの構築に挑戦しました。
CI/CDパイプラインを作成するためのJenkins/GitLabをインストールするために必要なHelmの使い方、アプリケーションを外部に公開するためのkubernetesオブジェクトのIngressも併せて使えるようになりました。

ここまでで Level3 は終了です。
